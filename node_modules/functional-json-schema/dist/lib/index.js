"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var lodash_1 = require("lodash");
var isTypeDescriptor = function (value) {
    return lodash_1.get(value, '__typename') === 'TypeDescriptor';
};
var isArrayTypeDescriptor = function (value) {
    return lodash_1.get(value, '__typename') === 'ArrayTypeDescriptor';
};
var getRequired = function (properties) {
    return lodash_1.compact(lodash_1.map(properties, function (type, k) { return isTypeDescriptor(type) && type.required ? k : undefined; }));
};
var schemaDescriptorReducer = function (result, curr, key) {
    if (isArrayTypeDescriptor(curr)) {
        result = (_a = {},
            _a[curr.name] = lodash_1.map(curr.rawType, function (td) { return schemaDescriptorReducer(result, td, key); }),
            _a);
    }
    else if (isTypeDescriptor(curr) && isTypeDescriptor(curr.rawType)) {
        result = schemaDescriptorReducer({}, curr.rawType, key);
    }
    else if (isTypeDescriptor(curr)) {
        result = curr.rawType;
    }
    else {
        result.properties[key] = {
            type: 'object',
            required: getRequired(curr),
            properties: {}
        };
        lodash_1.each(curr, function (v, k) {
            result.properties[key].properties[k] = __assign({}, lodash_1.omit(schemaDescriptorReducer(result.properties[key], v, k), ['required', '__typename']));
        });
    }
    return result;
    var _a;
};
exports.schema = function (schemaDescriptor, definitions, options) { return lodash_1.reduce(schemaDescriptor, schemaDescriptorReducer, __assign({ type: 'object', properties: {} }, (definitions ? { definitions: definitions } : {}), (options && options.schema ? { $schema: options.schema } : {}))); };
var wrapMany = function (name) { return function () {
    var typeDescriptors = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeDescriptors[_i] = arguments[_i];
    }
    return ({
        __typename: 'ArrayTypeDescriptor',
        required: false,
        name: name,
        rawType: typeDescriptors.map(types.normalize)
    });
}; };
var wrap = function (prop) { return function (typeDescriptor) {
    return ({
        __typename: 'TypeDescriptor',
        required: false,
        rawType: (_a = {}, _a[prop] = types.normalize(typeDescriptor), _a)
    });
    var _a;
}; };
var types;
(function (types) {
    types.normalize = function (typeDescriptor) {
        if (typeof typeDescriptor === 'string') {
            return types.type(typeDescriptor);
        }
        else {
            return typeDescriptor;
        }
    };
    types.allOf = wrapMany('allOf');
    types.anyOf = wrapMany('anyOf');
    types.oneOf = wrapMany('oneOf');
    types.enumOf = wrapMany('enum');
    types.arrayOf = function (typeDescriptor, options) { return constraints.required({
        __typename: 'TypeDescriptor',
        rawType: {
            type: 'array',
            items: types.normalize(typeDescriptor).rawType
        },
        required: false
    }, options && options.required ? options.required : false); };
    types.definition = function (ref) { return ({
        __typename: 'TypeDescriptor',
        rawType: { $ref: "#/definitions/" + ref },
        required: false
    }); };
    types.type = function (type, options) { return constraints.required({
        __typename: 'TypeDescriptor',
        rawType: { type: type },
        required: false
    }, options && options.required ? options.required : false); };
})(types = exports.types || (exports.types = {}));
var constraints;
(function (constraints) {
    constraints.required = function (typeDescriptor, required) { return (__assign({}, typeDescriptor, { required: required })); };
    constraints.pattern = function (reg) { };
})(constraints = exports.constraints || (exports.constraints = {}));
